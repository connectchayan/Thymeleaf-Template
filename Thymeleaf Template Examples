@Configuration
public class SecurityConfig {
    @Value("${jwt.secret}") // Replace with your own property for JWT secret
    private String jwtSecret;

    @Value("${jwt.issuer}") // Replace with your own property for JWT issuer
    private String jwtIssuer;

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(
            ServerHttpSecurity http,
            ReactiveAuthenticationManager authenticationManager,
            ReactiveAuthorizationManager<AuthorizationContext> authorizationManager,
            ServerSecurityContextRepository securityContextRepository
    ) {
        return http
                .authorizeExchange()
                .pathMatchers("/author/**").hasAuthority("author")
                .anyExchange().authenticated()
                .and()
                .addFilterAt(jwtAuthenticationWebFilter(authenticationManager), SecurityWebFiltersOrder.AUTHENTICATION)
                .securityContextRepository(securityContextRepository)
                .csrf().disable()
                .build();
    }

    @Bean
    public ReactiveAuthenticationManager authenticationManager(ReactiveUserDetailsService userDetailsService) {
        return authentication -> userDetailsService.findByUsername(authentication.getName())
                .flatMap(userDetails -> {
                    String token = extractTokenFromRequest(authentication);
                    Pair<String, String> authPrincipals = JWTUtils.extractAuthPrincipals(token);
                    if (validateToken(token)) {
                        List<SimpleGrantedAuthority> authorities = userDetails.getAuthorities().stream()
                                .map(SimpleGrantedAuthority::new)
                                .collect(Collectors.toList());
                        Authentication authenticated = new UsernamePasswordAuthenticationToken(userDetails, null, authorities);
                        return Mono.just(authenticated);
                    } else {
                        return Mono.empty();
                    }
                });
    }

    @Bean
    public ReactiveAuthorizationManager<AuthorizationContext> authorizationManager() {
        return (authentication, context) -> {
            if (context.getExchange().getRequest().getPath().toString().startsWith("/author/")) {
                return Flux.just(new AuthorizationDecision(authentication.getAuthorities().stream()
                        .anyMatch(authority -> authority.getAuthority().equals("author"))));
            }
            return Mono.just(new AuthorizationDecision(true));
        };
    }

    @Bean
    public WebFilter jwtAuthenticationWebFilter(ReactiveAuthenticationManager authenticationManager) {
        AuthenticationWebFilter authenticationWebFilter = new AuthenticationWebFilter(authenticationManager);
        authenticationWebFilter.setServerAuthenticationConverter(new JwtAuthenticationConverter(jwtSecret, jwtIssuer));
        authenticationWebFilter.setRequiresAuthenticationMatcher(ServerWebExchangeMatchers.pathMatchers("/api/**")); // Adjust the path pattern for JWT authentication
        return authenticationWebFilter;
    }

    @Bean
    public ServerSecurityContextRepository securityContextRepository() {
        return new WebSessionServerSecurityContextRepository();
    }

    private String extractTokenFromRequest(Authentication authentication) {
        Object credentials = authentication.getCredentials();
        if (credentials instanceof String) {
            return (String) credentials;
        }
        return null;
    }

    private boolean validateToken(String token) {
        Optional<JWTClaimsSet> claimsSet = JWTUtils.decodeClaims(token);
        // Implement your token validation logic using JWTUtils or your preferred JWT library
    }
}



===========================================================
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.web.server.authentication.ServerAuthenticationConverter;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

public class JwtAuthenticationConverter implements ServerAuthenticationConverter {
    private final String jwtSecret;
    private final String jwtIssuer;

    public JwtAuthenticationConverter(String jwtSecret, String jwtIssuer) {
        this.jwtSecret = jwtSecret;
        this.jwtIssuer = jwtIssuer;
    }

    @Override
    public Mono<Authentication> convert(ServerWebExchange exchange) {
        String token = extractTokenFromRequest(exchange);

        // Validate the token and extract the principal and claims
        Principal principal = validateTokenAndGetPrincipal(token);
        Claims claims = validateTokenAndGetClaims(token);

        // Store the principal and claims in the SecurityContext
        return ReactiveSecurityContextHolder.getContext()
                .map(context -> {
                    context.setAuthentication(new UsernamePasswordAuthenticationToken(principal, claims));
                    return context.getAuthentication();
                });
    }

    private String extractTokenFromRequest(ServerWebExchange exchange) {
        String authorizationHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);
        if (StringUtils.hasText(authorizationHeader) && authorizationHeader.startsWith("Bearer ")) {
            return authorizationHeader.substring(7);
        }
        return null;
    }

    private Principal validateTokenAndGetPrincipal(String token) {
        // Validate the token and extract the principal
        // (Implement your validation logic using your preferred JWT library)
    }

    private Claims validateTokenAndGetClaims(String token) {
        // Validate the token and extract the claims
        // (Implement your validation logic using your preferred JWT library)
    }
}
  ===============================================================================
  import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.web.server.authentication.ServerAuthenticationConverter;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

public class JwtAuthenticationConverter implements ServerAuthenticationConverter {
    private final String jwtSecret;
    private final String jwtIssuer;

    public JwtAuthenticationConverter(String jwtSecret, String jwtIssuer) {
        this.jwtSecret = jwtSecret;
        this.jwtIssuer = jwtIssuer;
    }

    @Override
    public Mono<Authentication> convert(ServerWebExchange exchange) {
        String token = extractTokenFromRequest(exchange);

        // Validate the token and extract the principal and claims
        Principal principal = validateTokenAndGetPrincipal(token);
        Claims claims = validateTokenAndGetClaims(token);

        // Store the principal and claims in the SecurityContext
        return ReactiveSecurityContextHolder.getContext()
                .map(context -> {
                    context.setAuthentication(new UsernamePasswordAuthenticationToken(principal, claims));
                    return context.getAuthentication();
                });
    }

    private String extractTokenFromRequest(ServerWebExchange exchange) {
        String authorizationHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);
        if (StringUtils.hasText(authorizationHeader) && authorizationHeader.startsWith("Bearer ")) {
            return authorizationHeader.substring(7);
        }
        return null;
    }

    private Principal validateTokenAndGetPrincipal(String token) {
        // Validate the token and extract the principal
        // (Implement your validation logic using your preferred JWT library)
    }

    private Claims validateTokenAndGetClaims(String token) {
        // Validate the token and extract the claims
        // (Implement your validation logic using your preferred JWT library)
    }
}
