@Configuration
public class SecurityConfig {
    @Value("${jwt.secret}") // Replace with your own property for JWT secret
    private String jwtSecret;

    @Value("${jwt.issuer}") // Replace with your own property for JWT issuer
    private String jwtIssuer;

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(
            ServerHttpSecurity http,
            ReactiveAuthenticationManager authenticationManager,
            ReactiveAuthorizationManager<AuthorizationContext> authorizationManager,
            ServerSecurityContextRepository securityContextRepository
    ) {
        return http
                .authorizeExchange()
                .pathMatchers("/author/**").hasAuthority("author")
                .anyExchange().authenticated()
                .and()
                .addFilterAt(jwtAuthenticationWebFilter(authenticationManager), SecurityWebFiltersOrder.AUTHENTICATION)
                .securityContextRepository(securityContextRepository)
                .csrf().disable()
                .build();
    }

    @Bean
    public ReactiveAuthenticationManager authenticationManager(ReactiveUserDetailsService userDetailsService) {
        return authentication -> userDetailsService.findByUsername(authentication.getName())
                .flatMap(userDetails -> {
                    String token = extractTokenFromRequest(authentication);
                    Pair<String, String> authPrincipals = JWTUtils.extractAuthPrincipals(token);
                    if (validateToken(token)) {
                        List<SimpleGrantedAuthority> authorities = userDetails.getAuthorities().stream()
                                .map(SimpleGrantedAuthority::new)
                                .collect(Collectors.toList());
                        Authentication authenticated = new UsernamePasswordAuthenticationToken(userDetails, null, authorities);
                        return Mono.just(authenticated);
                    } else {
                        return Mono.empty();
                    }
                });
    }

    @Bean
    public ReactiveAuthorizationManager<AuthorizationContext> authorizationManager() {
        return (authentication, context) -> {
            if (context.getExchange().getRequest().getPath().toString().startsWith("/author/")) {
                return Flux.just(new AuthorizationDecision(authentication.getAuthorities().stream()
                        .anyMatch(authority -> authority.getAuthority().equals("author"))));
            }
            return Mono.just(new AuthorizationDecision(true));
        };
    }

    @Bean
    public WebFilter jwtAuthenticationWebFilter(ReactiveAuthenticationManager authenticationManager) {
        AuthenticationWebFilter authenticationWebFilter = new AuthenticationWebFilter(authenticationManager);
        authenticationWebFilter.setServerAuthenticationConverter(new JwtAuthenticationConverter(jwtSecret, jwtIssuer));
        authenticationWebFilter.setRequiresAuthenticationMatcher(ServerWebExchangeMatchers.pathMatchers("/api/**")); // Adjust the path pattern for JWT authentication
        return authenticationWebFilter;
    }

    @Bean
    public ServerSecurityContextRepository securityContextRepository() {
        return new WebSessionServerSecurityContextRepository();
    }

    private String extractTokenFromRequest(Authentication authentication) {
        Object credentials = authentication.getCredentials();
        if (credentials instanceof String) {
            return (String) credentials;
        }
        return null;
    }

    private boolean validateToken(String token) {
        Optional<JWTClaimsSet> claimsSet = JWTUtils.decodeClaims(token);
        // Implement your token validation logic using JWTUtils or your preferred JWT library
    }
}



===========================================================
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.web.server.authentication.ServerAuthenticationConverter;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

public class JwtAuthenticationConverter implements ServerAuthenticationConverter {
    private final String jwtSecret;
    private final String jwtIssuer;

    public JwtAuthenticationConverter(String jwtSecret, String jwtIssuer) {
        this.jwtSecret = jwtSecret;
        this.jwtIssuer = jwtIssuer;
    }

    @Override
    public Mono<Authentication> convert(ServerWebExchange exchange) {
        String token = extractTokenFromRequest(exchange);

        // Validate the token and extract the principal and claims
        Principal principal = validateTokenAndGetPrincipal(token);
        Claims claims = validateTokenAndGetClaims(token);

        // Store the principal and claims in the SecurityContext
        return ReactiveSecurityContextHolder.getContext()
                .map(context -> {
                    context.setAuthentication(new UsernamePasswordAuthenticationToken(principal, claims));
                    return context.getAuthentication();
                });
    }

    private String extractTokenFromRequest(ServerWebExchange exchange) {
        String authorizationHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);
        if (StringUtils.hasText(authorizationHeader) && authorizationHeader.startsWith("Bearer ")) {
            return authorizationHeader.substring(7);
        }
        return null;
    }

    private Principal validateTokenAndGetPrincipal(String token) {
        // Validate the token and extract the principal
        // (Implement your validation logic using your preferred JWT library)
    }

    private Claims validateTokenAndGetClaims(String token) {
        // Validate the token and extract the claims
        // (Implement your validation logic using your preferred JWT library)
    }
}
  ===============================================================================
  import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.web.server.authentication.ServerAuthenticationConverter;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

public class JwtAuthenticationConverter implements ServerAuthenticationConverter {
    private final String jwtSecret;
    private final String jwtIssuer;

    public JwtAuthenticationConverter(String jwtSecret, String jwtIssuer) {
        this.jwtSecret = jwtSecret;
        this.jwtIssuer = jwtIssuer;
    }

    @Override
    public Mono<Authentication> convert(ServerWebExchange exchange) {
        String token = extractTokenFromRequest(exchange);

        // Validate the token and extract the principal and claims
        Principal principal = validateTokenAndGetPrincipal(token);
        Claims claims = validateTokenAndGetClaims(token);

        // Store the principal and claims in the SecurityContext
        return ReactiveSecurityContextHolder.getContext()
                .map(context -> {
                    context.setAuthentication(new UsernamePasswordAuthenticationToken(principal, claims));
                    return context.getAuthentication();
                });
    }

    private String extractTokenFromRequest(ServerWebExchange exchange) {
        String authorizationHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);
        if (StringUtils.hasText(authorizationHeader) && authorizationHeader.startsWith("Bearer ")) {
            return authorizationHeader.substring(7);
        }
        return null;
    }

    private Principal validateTokenAndGetPrincipal(String token) {
        // Validate the token and extract the principal
        // (Implement your validation logic using your preferred JWT library)
    }

    private Claims validateTokenAndGetClaims(String token) {
        // Validate the token and extract the claims
        // (Implement your validation logic using your preferred JWT library)
    }
}
==========================================================================================
private final ReactiveAuthenticationManager authenticationManager;

    public AuthenticationFilter(ReactiveAuthenticationManager authenticationManager) {
        this.authenticationManager = authenticationManager;
    }
private Mono<Authentication> authenticate(ServerWebExchange exchange) {
    // Implement your authentication logic here
    // Validate the authentication credentials and create an Authentication object
    
    // Example: Extract the JWT token from the request headers
    String authorizationHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);

    if (StringUtils.hasText(authorizationHeader) && authorizationHeader.startsWith(BEARER)) {
        String jwtToken = authorizationHeader.substring(BEARER.length());

        try {
            // Validate and parse the JWT token
            Claims claims = Jwts.parser().parseClaimsJws(jwtToken).getBody();
            String username = claims.getSubject();
            String authorities = claims.get("authorities", String.class);

            if (StringUtils.hasText(username) && StringUtils.hasText(authorities)) {
                UserDetails userDetails = new UserDetailsImpl(username,
                        AuthorityUtils.commaSeparatedStringToAuthorityList(authorities));

                // Create an Authentication object with the user details
                AbstractAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());

                return Mono.just(authenticationToken);
            }
        } catch (Exception e) {
            // Handle token parsing or verification errors
            throw new BadCredentialsException("Invalid token");
        }
    }

    return Mono.empty(); // Return empty if authentication fails
}

@Override
public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
    return authenticate(exchange)
            .flatMap(authentication -> authorize(exchange, authentication)
                    .thenReturn(authentication))
            .switchIfEmpty(Mono.defer(() -> handleUnauthenticated(exchange)))
            .flatMap(authentication -> {
                SecurityContextImpl securityContext = new SecurityContextImpl();
                securityContext.setAuthentication(authentication);
                return chain.filter(exchange).subscriberContext(ReactiveSecurityContextHolder.withSecurityContext(Mono.just(securityContext)));
            })
            .subscriberContext(ReactiveSecurityContextHolder.clearContextOnEachIteration());
}

private Mono<Void> handleUnauthenticated(ServerWebExchange exchange) {
    exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
    return exchange.getResponse().setComplete();
}

private Mono<Void> authorize(ServerWebExchange exchange, Authentication authentication) {
    // Implement your authorization logic here
    // Check if the authenticated user has the necessary roles/permissions
    // You can use Spring Security's authorization mechanisms
    // For example, you can use method-level security annotations, custom logic, etc.
    // You can access the user's authorities using authentication.getAuthorities()
    // Return Mono.error if authorization fails, or Mono.empty() if it succeeds
    
    // Example: All authenticated users have access to "/public/**" endpoints
    String requestPath = exchange.getRequest().getPath().value();
    if (requestPath.startsWith("/public/")) {
        return Mono.empty(); // Allow access
    }
    
    // Example: Check if the authenticated user has the required authority
    if (authentication.getAuthorities().stream()
            .anyMatch(authority -> authority.getAuthority().equals("ROLE_ADMIN"))) {
        return Mono.empty(); // Allow access
    }
    
    // If the authorization check fails, return Mono.error with appropriate response
    return Mono.error(new AccessDeniedException("Access denied"));
}

import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.mock.web.server.MockServerWebExchange;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextImpl;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.security.test.context.support.WithSecurityContextTestExecutionListener;
import org.springframework.security.test.context.support.WithUserDetails;
import org.springframework.security.test.context.support.WithSecurityContext;
import org.springframework.security.test.context.support.WithSecurityContextFactory;
import org.springframework.security.test.web.reactive.server.SecurityMockServerConfigurers;
import org.springframework.security.test.web.reactive.server.SecurityMockServerConfigurers.MockUserSpec;
import org.springframework.test.web.reactive.server.WebTestClient;
import reactor.core.publisher.Mono;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

public class FilterTests {

    @Test
    public void testPublicPath() {
        // Arrange
        ServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get("/public"));
        WebFilterChain chain = Mockito.mock(WebFilterChain.class);
        Filter filter = new Filter();

        // Act
        Mono<Void> result = filter.filter(exchange, chain);

        // Assert
        StepVerifier.create(result)
            .verifyComplete();
        Mockito.verify(chain, Mockito.times(1)).filter(exchange);
    }

    @Test
    public void testAuthenticatedPath() {
        // Arrange
        ServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get("/secured"));
        WebFilterChain chain = Mockito.mock(WebFilterChain.class);
        Authentication authentication = Mockito.mock(Authentication.class);
        when(filter.authenticate(any())).thenReturn(Mono.just(authentication));
        when(filter.authorize(any(), any())).thenReturn(Mono.just(authentication));
        Filter filter = new Filter();

        // Act
        Mono<Void> result = filter.filter(exchange, chain);

        // Assert
        StepVerifier.create(result)
            .verifyComplete();
        Mockito.verify(chain, Mockito.times(1)).filter(exchange);
        Mockito.verify(filter, Mockito.times(1)).authenticate(exchange);
        Mockito.verify(filter, Mockito.times(1)).authorize(exchange, authentication);
    }

    @Test
    public void testWebClientPublicPath() {
        // Arrange
        Filter filter = new Filter();
        WebTestClient webClient = WebTestClient.bindToController(filter)
            .configureClient()
            .filter(SecurityMockServerConfigurers.csrf())
            .build();

        // Act
        ResponseSpec response = webClient.method(HttpMethod.GET)
            .uri("/public")
            .exchange();

        // Assert
        response.expectStatus().isOk();
    }

    @Test
    public void testWebClientAuthenticatedPath() {
        // Arrange
        Filter filter = new Filter();
        WebTestClient webClient = WebTestClient.bindToController(filter)
            .configureClient()
            .filter(SecurityMockServerConfigurers.csrf())
            .build();

        // Act
        ResponseSpec response = webClient.method(HttpMethod.GET)
            .uri("/secured")
            .exchange();

        // Assert
        response.expectStatus().isOk();
    }
}
