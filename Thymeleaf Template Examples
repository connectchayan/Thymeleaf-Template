@Configuration
public class SecurityConfig {
    @Value("${jwt.secret}") // Replace with your own property for JWT secret
    private String jwtSecret;

    @Value("${jwt.issuer}") // Replace with your own property for JWT issuer
    private String jwtIssuer;

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(
            ServerHttpSecurity http,
            ReactiveAuthenticationManager authenticationManager,
            ReactiveAuthorizationManager<AuthorizationContext> authorizationManager,
            ServerSecurityContextRepository securityContextRepository
    ) {
        return http
                .authorizeExchange()
                .pathMatchers("/author/**").hasAuthority("author")
                .anyExchange().authenticated()
                .and()
                .addFilterAt(jwtAuthenticationWebFilter(authenticationManager), SecurityWebFiltersOrder.AUTHENTICATION)
                .securityContextRepository(securityContextRepository)
                .csrf().disable()
                .build();
    }

    @Bean
    public ReactiveAuthenticationManager authenticationManager(ReactiveUserDetailsService userDetailsService) {
        return authentication -> userDetailsService.findByUsername(authentication.getName())
                .flatMap(userDetails -> {
                    String token = extractTokenFromRequest(authentication);
                    Pair<String, String> authPrincipals = JWTUtils.extractAuthPrincipals(token);
                    if (validateToken(token)) {
                        List<SimpleGrantedAuthority> authorities = userDetails.getAuthorities().stream()
                                .map(SimpleGrantedAuthority::new)
                                .collect(Collectors.toList());
                        Authentication authenticated = new UsernamePasswordAuthenticationToken(userDetails, null, authorities);
                        return Mono.just(authenticated);
                    } else {
                        return Mono.empty();
                    }
                });
    }

    @Bean
    public ReactiveAuthorizationManager<AuthorizationContext> authorizationManager() {
        return (authentication, context) -> {
            if (context.getExchange().getRequest().getPath().toString().startsWith("/author/")) {
                return Flux.just(new AuthorizationDecision(authentication.getAuthorities().stream()
                        .anyMatch(authority -> authority.getAuthority().equals("author"))));
            }
            return Mono.just(new AuthorizationDecision(true));
        };
    }

    @Bean
    public WebFilter jwtAuthenticationWebFilter(ReactiveAuthenticationManager authenticationManager) {
        AuthenticationWebFilter authenticationWebFilter = new AuthenticationWebFilter(authenticationManager);
        authenticationWebFilter.setServerAuthenticationConverter(new JwtAuthenticationConverter(jwtSecret, jwtIssuer));
        authenticationWebFilter.setRequiresAuthenticationMatcher(ServerWebExchangeMatchers.pathMatchers("/api/**")); // Adjust the path pattern for JWT authentication
        return authenticationWebFilter;
    }

    @Bean
    public ServerSecurityContextRepository securityContextRepository() {
        return new WebSessionServerSecurityContextRepository();
    }

    private String extractTokenFromRequest(Authentication authentication) {
        Object credentials = authentication.getCredentials();
        if (credentials instanceof String) {
            return (String) credentials;
        }
        return null;
    }

    private boolean validateToken(String token) {
        Optional<JWTClaimsSet> claimsSet = JWTUtils.decodeClaims(token);
        // Implement your token validation logic using JWTUtils or your preferred JWT library
    }
}



===========================================================
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.web.server.authentication.ServerAuthenticationConverter;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

public class JwtAuthenticationConverter implements ServerAuthenticationConverter {
    private final String jwtSecret;
    private final String jwtIssuer;

    public JwtAuthenticationConverter(String jwtSecret, String jwtIssuer) {
        this.jwtSecret = jwtSecret;
        this.jwtIssuer = jwtIssuer;
    }

    @Override
    public Mono<Authentication> convert(ServerWebExchange exchange) {
        String token = extractTokenFromRequest(exchange);

        // Validate the token and extract the principal and claims
        Principal principal = validateTokenAndGetPrincipal(token);
        Claims claims = validateTokenAndGetClaims(token);

        // Store the principal and claims in the SecurityContext
        return ReactiveSecurityContextHolder.getContext()
                .map(context -> {
                    context.setAuthentication(new UsernamePasswordAuthenticationToken(principal, claims));
                    return context.getAuthentication();
                });
    }

    private String extractTokenFromRequest(ServerWebExchange exchange) {
        String authorizationHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);
        if (StringUtils.hasText(authorizationHeader) && authorizationHeader.startsWith("Bearer ")) {
            return authorizationHeader.substring(7);
        }
        return null;
    }

    private Principal validateTokenAndGetPrincipal(String token) {
        // Validate the token and extract the principal
        // (Implement your validation logic using your preferred JWT library)
    }

    private Claims validateTokenAndGetClaims(String token) {
        // Validate the token and extract the claims
        // (Implement your validation logic using your preferred JWT library)
    }
}
  ===============================================================================
  import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.web.server.authentication.ServerAuthenticationConverter;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

public class JwtAuthenticationConverter implements ServerAuthenticationConverter {
    private final String jwtSecret;
    private final String jwtIssuer;

    public JwtAuthenticationConverter(String jwtSecret, String jwtIssuer) {
        this.jwtSecret = jwtSecret;
        this.jwtIssuer = jwtIssuer;
    }

    @Override
    public Mono<Authentication> convert(ServerWebExchange exchange) {
        String token = extractTokenFromRequest(exchange);

        // Validate the token and extract the principal and claims
        Principal principal = validateTokenAndGetPrincipal(token);
        Claims claims = validateTokenAndGetClaims(token);

        // Store the principal and claims in the SecurityContext
        return ReactiveSecurityContextHolder.getContext()
                .map(context -> {
                    context.setAuthentication(new UsernamePasswordAuthenticationToken(principal, claims));
                    return context.getAuthentication();
                });
    }

    private String extractTokenFromRequest(ServerWebExchange exchange) {
        String authorizationHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);
        if (StringUtils.hasText(authorizationHeader) && authorizationHeader.startsWith("Bearer ")) {
            return authorizationHeader.substring(7);
        }
        return null;
    }

    private Principal validateTokenAndGetPrincipal(String token) {
        // Validate the token and extract the principal
        // (Implement your validation logic using your preferred JWT library)
    }

    private Claims validateTokenAndGetClaims(String token) {
        // Validate the token and extract the claims
        // (Implement your validation logic using your preferred JWT library)
    }
}
==========================================================================================

private final ReactiveAuthenticationManager authenticationManager;

    public AuthenticationFilter(ReactiveAuthenticationManager authenticationManager) {
        this.authenticationManager = authenticationManager;
    }

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        return authenticate(exchange)
                .flatMap(authentication -> {
                    SecurityContextHolder.getContext().setAuthentication(authentication);
                    return authorize(exchange, authentication);
                })
                .switchIfEmpty(Mono.defer(() -> handleUnauthenticated(exchange)))
                .flatMap(aVoid -> chain.filter(exchange))
                .doFinally(signal -> SecurityContextHolder.clearContext());
    }

    private Mono<Void> authorize(ServerWebExchange exchange, Authentication authentication) {
        // Implement your authorization logic here
        // Check if the authenticated user has the necessary roles/permissions
        // You can use Spring Security's authorization mechanisms
        // For example, you can use method-level security annotations, custom logic, etc.
        // You can access the user's authorities using authentication.getAuthorities()
        // Return Mono.error if authorization fails, or Mono.empty() if it succeeds
        return Mono.empty();
    }

    private Mono<Void> handleUnauthenticated(ServerWebExchange exchange) {
        // Handle unauthenticated requests, e.g., return an HTTP 401 Unauthorized status
        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
        return exchange.getResponse().setComplete();
    }

    private Mono<Authentication> authenticate(ServerWebExchange exchange) {
        String authorizationHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);

        if (StringUtils.hasText(authorizationHeader) && authorizationHeader.startsWith(BEARER)) {
            String jwtToken = authorizationHeader.substring(BEARER.length());

            try {
                Claims claims = Jwts.parser().parseClaimsJws(jwtToken).getBody();
                String username = claims.getSubject();
                String authorities = claims.get("authorities", String.class);

                if (StringUtils.hasText(username) && StringUtils.hasText(authorities)) {
                    UserDetails userDetails = new UserDetailsImpl(username,
                            AuthorityUtils.commaSeparatedStringToAuthorityList(authorities));

                    AbstractAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(
                            userDetails, null, userDetails.getAuthorities());

                    return authenticationManager.authenticate(authenticationToken);
                }
            } catch (Exception e) {
                // Handle token parsing or verification errors
                throw new BadCredentialsException("Invalid token");
            }
        }

        return Mono.empty();
    }
}
